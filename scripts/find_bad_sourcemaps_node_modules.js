const fs = require('fs');
const path = require('path');

const ROOT = path.resolve(__dirname, '..');
const NODE_MODULES = path.join(ROOT, 'node_modules');

const jsExt = new Set(['.js', '.cjs', '.mjs', '.ts', '.map']);

function walk(dir, cb) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      // recurse
      walk(full, cb);
    } else if (e.isFile()) {
      if (jsExt.has(path.extname(e.name))) cb(full);
    }
  }
}

const bad = [];

function report(file, reason, excerpt) {
  bad.push({ file, reason, excerpt });
  console.log('[BAD]', file, '-', reason);
  if (excerpt) console.log('  excerpt:', excerpt.trim().slice(0, 400));
}

function tryDecodeBase64Payload(payload) {
  try {
    // remove whitespace
    const cleaned = payload.replace(/\s+/g, '');
    // quick base64 char validation
    if (!/^[A-Za-z0-9+/=]+$/.test(cleaned)) {
      return { ok: false, reason: 'base64 invalid chars' };
    }
    // length mod 4 warning (not fatal)
    if (cleaned.length % 4 !== 0) {
      // continue attempt
    }
    const buf = Buffer.from(cleaned, 'base64');
    const str = buf.toString('utf8');
    try {
      JSON.parse(str);
      return { ok: true };
    } catch (e) {
      return { ok: false, reason: 'json parse failed', message: e.message };
    }
  } catch (e) {
    return { ok: false, reason: 'decode failed', message: e.message };
  }
}

console.log('Scanning node_modules for sourceMappingURL patterns...');
if (!fs.existsSync(NODE_MODULES)) {
  console.log('No node_modules directory found at', NODE_MODULES);
  process.exit(0);
}

walk(NODE_MODULES, (file) => {
  let s;
  try {
    s = fs.readFileSync(file, 'utf8');
  } catch (e) {
    console.warn('Failed to read', file, e.message);
    return;
  }
  // find occurrences of sourceMappingURL in the file
  const re = /(sourceMappingURL=)([^\s*'"\)]+)([^\n\r]*)/g;
  let m;
  while ((m = re.exec(s)) !== null) {
    const full = m[0];
    const target = m[2];
    // check for concatenated pattern: sourceMappingURL=...//# sourceURL
    const restOfLine = s.slice(m.index, s.indexOf('\n', m.index) === -1 ? s.length : s.indexOf('\n', m.index));
    if (/sourceMappingURL=[^\n]*\/\/\#\s*sourceURL/.test(restOfLine)) {
      report(file, 'concatenated sourceMappingURL and sourceURL on same line', restOfLine);
    }

    // if target starts with data: -> inline map
    if (/^data:/i.test(target)) {
      // match data:application/json...base64,<payload>
      const dataMatch = target.match(/data:(?:application|text)\/json(?:;charset=[^;]+)?;(?:base64,)?(.*)$/i);
      if (dataMatch) {
        const payload = dataMatch[1];
        if (!payload) {
          report(file, 'inline data uri missing payload', full);
          continue;
        }
        const res = tryDecodeBase64Payload(payload);
        if (!res.ok) {
          report(file, `inline map decode error: ${res.reason}${res.message ? ' - ' + res.message : ''}`, full);
        }
      } else {
        // data: but not expected json/base64 pattern
        report(file, 'data: URL for sourceMappingURL not matching expected json;base64 pattern', full);
      }
    } else {
      // file reference; check if it's followed by '//# sourceURL' without newline
      const line = restOfLine;
      if (/sourceURL/.test(line)) {
        report(file, 'sourceMappingURL referenced and sourceURL on same line', line);
      }
    }
  }
});

console.log('\nScan complete.');
if (bad.length === 0) {
  console.log('No suspicious sourceMappingURL patterns found in node_modules.');
  process.exit(0);
} else {
  console.log(`Found ${bad.length} suspicious entries.`);
  process.exit(2);
}
